# INITLAIZE DIVISOR TO 1 
# R0, R1, R2 -> M[22][23][24]
SEI 0
ADD R0, RIM
SEI 1
ADD R1, RIM
SEI 0 
ADD R2, RIM
SEI 22
SW R0, RIM
SEI 23
SW R1, RIM
SEI 24
SW R2, RIM
SUB R0, R0
SUB R1, R1
SUB R2, R2
SEI 0
ADD R3, RIM
ADD R4, RIM
ADD R5, RIM
ADD R6, RIM

# LOAD DIVIDENT (R0, R1, R2)
SEI 16
LW R0, RIM
SEI 17
LW R1, RIM
# CHECK IF 0
SEI 0
CEQ R0, RIM
B0 0
CEQ R1, RIM
B1 7

SUB R1, R1
SUB R0, R0

TOP:
# RESET COMPARE, RESET QUOTIENT, COUNTER
# INTIALIZE COMPARE TO 0, SAVE TO MEM
# R3, R4, R5 -> M[28][29][30]
SUB R3, R3
SUB R4, R4
SUB R5, R5
SEI 28
SW R3, RIM
SEI 29
SW R4, RIM
SEI 30
SW R5, RIM
SUB R3, R3
SUB R4, R4
SUB R5, R5

# INITALIZE QUOTIENT TO 0
# R0, R1, R2 -> M[25][26][27]
SEI 0
SUB R0, R0
SUB R1, R1
SUB R2, R2
SEI 25
SW R0, RIM
SEI 26
SW R1, RIM
SEI 27
SW R2, RIM
SUB R0, R0
SUB R1, R1
SUB R2, R2

# LOAD DIVIDENT (R0, R1, R2)
SEI 16
LW R0, RIM
SEI 17
LW R1, RIM
SEI 0 # APPEND 8 0s AT THE END OF DIVIDEND
SUB R2, R2
ADD R2, RIM
SEI 19
SW R0, RIM
SEI 20
SW R1, RIM
SEI 21
SW R2, RIM
SUB R0, R0
SUB R1, R1
SUB R2, R2

DIVLOOP: 
# LOAD DIVIDENT (R0, R1, R2)
SEI 19
LW R0, RIM
SEI 20
LW R1, RIM
SEI 21
LW R2, RIM

# LOAD COMPARE (R3, R4, R5)
SEI 28
LW R3, RIM
SEI 29
LW R4, RIM
SEI 30
LW R5, RIM 

# SHIFT DIVIDENT LEFT
SHIFTL_X R2
SHIFTL_O R1
SHIFTL_O R0


# SHIFT COMPARE
SHIFTL_O R4
SHIFTL_O R3

# STORE DIVIDENT BACK TO MEM
SEI 19
SW R0, RIM
SEI 20
SW R1, RIM
SEI 21
SW R2, RIM

# LOAD DIVISOR (R0, R1, R2)
SEI 22
LW R0, RIM
SEI 23
LW R1, RIM
SEI 24
LW R2, RIM 

# COMPARE THE DIVISOR WITH COMPARE REG
# MSB
CLT R0, R3
B1 2
CEQ R0, R3
B0 3

# LSB
CLT R1, R4
B1 2
CEQ R1, R4
B0 3

# FRAC
CLT R2, R5
B1 2
CEQ R2, R5
B0 3

COMPARELARGER:
SUB R5, R2
SUB R4, R1
SUB R3, R0

COMPARESMALLER:
# SAVE COMPARE REG (R3, R4, R5)
SEI 28
SW R3, RIM
SEI 29
SW R4, RIM
SEI 30
SW R5, RIM
# STORE DIVISOR
SEI 22
SW R0, RIM
SEI 23
SW R1, RIM
SEI 24
SW R2, RIM

# LOAD QUOTIENT (R0, R1, R2)
SEI 25
LW R0, RIM
SEI 26
LW R1, RIM

SHIFTL_F R1
SHIFTL_O R0

# STORE QUOTIENT 
SEI 25
SW R0, RIM
SEI 26
SW R1, RIM

# ADD COUNTER (R6)
SEI 31
LW R6, RIM
SEI 1
ADD R6, RIM
SEI 31
SW R6, RIM

SEI 16
CEQ R6, RIM

B0 1

# RESTART COUNTER
SUB R6, R6
SEI 31
SW R6, RIM

FRAC: 
# LOAD COUNTER
SEI 31
LW R6, RIM

# LOAD DIVISOR (R0, R1, R2)
SEI 22
LW R0, RIM
SEI 23
LW R1, RIM
SEI 24
LW R2, RIM

# LOAD COMPARE (R3, R4, R5)
SEI 28
LW R3, RIM
SEI 29
LW R4, RIM
SEI 30
LW R5, RIM 

# SHIFT COMPARE
SHIFTL_X R5
SHIFTL_O R4
SHIFTL_O R3

# COMPARE THE DIVISOR WITH COMPARE REG
# MSB
CLT R0, R3
B1 5
CEQ R0, R3
B0 6

# LSB
CLT R1, R4
B1 5
CEQ R1, R4
B0 6

# FRAC
CLT R2, R5
B1 5
CEQ R2, R5
B0 6


COMPARELARGER1:
SUB R5, R2
SUB R4, R1
SUB R3, R0


COMPARESMALLER1:
# LOAD QUOTIENT FRAC(R2)
SEI 27
LW R2, RIM
SHIFTL_F R2

# SAVE COMPARE REG (R3, R4, R5)
SEI 28
SW R3, RIM
SEI 29
SW R4, RIM
SEI 30
SW R5, RIM

# STORE QUOTIENT 
SEI 27
SW R2, RIM

# ADD COUNTER (R6)
SEI 31
LW R6, RIM
SEI 1
ADD R6, RIM
SEI 31
SW R6, RIM

SEI 8
CEQ R6, RIM
B0 4


# DIVISON DONE, MOVE ON CALCULATING Xn+1
# LOAD DIVISOR (R0, R1, R2)
SEI 22
LW R0, RIM
SEI 23
LW R1, RIM
SEI 24
LW R2, RIM
# LOAD QUOTIENT (R3, R4, R5)
SEI 25
LW R3, RIM
SEI 26
LW R4, RIM
SEI 27
LW R5, RIM

# NEW DIVISOR(R3, R4, R5) = DIVISOR(R0, R1, R2) + QUOTIENT(R3, R4, R5)
ADD R5, R2
ADD R4, R1
ADD R3, R0

# RIGHT NEW DIVISOR (R3, R4, R5) >> 1
SHIFTR_X R3
SHIFTR_O R4
SHIFTR_O R5

# STORE NEW DIVISOR 
SEI 22
SW R3, RIM
SEI 23
SW R4, RIM
SEI 24
SW R5, RIM
# RESET COUNTER
SEI 31
SUB R6, R6
SW R6, RIM
# COMPARE NEW DIVISOR (Xn+1) (R3, R4, R5) TO OLD DIVISOR (Xn) (R0, R1, R2)
CEQ R3, R0
B0 0
CEQ R4, R1
B0 0
CEQ R5, R2
B0 0


# STORE FINAL RESULT INTO MEM 18
# ROUNDING
SUB R3, R3
# LOAD QUOTIENT (R0, R1, R2)
SEI 25
LW R0, RIM
SEI 26
LW R1, RIM
SEI 27
LW R2, RIM

# CHECK FOR HUGE NUMBER
SEI 63
ADD R6, RIM
CEQ R6, R6
SHIFTL_F R6
SHIFTL_F R6
CEQ R1, R6
B1 7

SHIFTL_X R2
SHIFTL_O R3 # THE 1ST BIT IN QUOTIENT FRAC 
SEI 0
CEQ R3, RIM
B1 7
SEI 1
ADD R1, RIM

NOROUNDUP:
SEI 18
SW R1, RIM

# TOP = 0
# DIVLOOP = 1
# COMPARELARGER = 2
# COMPARESMALLER = 3
# FRAC = 4
# COMPARELARGER1 = 5
# COMPARESMALLER1 = 6
# NOROUNDUP = 7